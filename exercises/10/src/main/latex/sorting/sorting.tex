\documentclass[a4paper]{article}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{multirow}
\graphicspath{{../../graphviz/}}
\DeclareGraphicsExtensions{.png}
\usepackage{verbatim}

\usepackage{listings}
\lstset{numbers=left, 
		basicstyle=\footnotesize,
		linewidth=\textwidth,
		tabsize=2}

\newcommand{\w}[1] {
		\tikz[label distance=2mm]
		\node[circle,fill=white]{#1};
}

\newcommand{\n}[1] {
		\tikz[label distance=2mm]
		\node[circle,fill=green!45]{#1};
}

\newcommand{\e}[1] {
		\tikz[label distance=2mm]
		\node[circle,fill=gray!45]{#1};
}

\newcommand{\fig}[3] {
	\begin{figure}[!h]
		\begin{center}
			\includegraphics[scale=0.4]{#1.png}
		\end{center}
		\caption{#2}
		\label{fig:#3}
	\end{figure}
}

\newcommand{\lstquote}[2]{
\lstinputlisting[language=Java, 
                 firstnumber=#1,
				 linerange={#1-#2}]
{../../../src/main/java/stickDivision/StickDivision2.java}
}

\begin{document}

\section*{H 10.4 Vergleich Insertion und Selectionsort}

\subsection*{a)}

\begin{table}[h!]
	\centering
	\caption{Selectionsort}
	\begin{tabular}{|ccccccccc|}
		\hline
		\w{22} & \w{17} & \w{13} & \w{56} & \n{95} & \w{44} & \w{30} &
		\w{21} & \w{19} \\	

		\e{95} & \w{17} & \w{13} & \n{56} & \w{22} & \w{44} & \w{30} &
		\w{21} & \w{19} \\	

		\w{95} & \e{56} & \w{13} & \w{17} & \w{22} & \n{44} & \w{30} &
		\w{21} & \w{19} \\	

		\w{95} & \w{56} & \e{44} & \w{17} & \w{22} & \w{13} & \n{30} &
		\w{21} & \w{19} \\	

		\w{95} & \w{56} & \w{44} & \e{30} & \n{22} & \w{13} & \w{17} & 
		\w{21} & \w{19} \\	

		\w{95} & \w{56} & \w{44} & \w{30} & \e{22} & \w{13} & \w{17} & 
		\n{21} & \w{19} \\	

		\w{95} & \w{56} & \w{44} & \w{30} & \w{22} & \e{21} & \w{17} &
		\w{13} & \n{19} \\	
		
		\w{95} & \w{56} & \w{44} & \w{30} & \w{22} & \w{21} & \e{19} &
		\w{13} & \n{17} \\	

		\w{95} & \w{56} & \w{44} & \w{30} & \w{22} & \w{21} & \w{19} &
		\e{17} & \n{13} \\	

		\w{95} & \w{56} & \w{44} & \w{30} & \w{22} & \w{21} & \w{19} &
		\w{17} & \e{13} \\	
		\hline
	\end{tabular}
	\label{tab:selectionsort}
\end{table}

\begin{table}[h!]
	\centering
	\caption{Insertionsort}
	\begin{tabular}{|ccccccccc|}
		\hline
		\e{22} & \n{17} & \w{13} & \w{56} & \w{95} & \w{44} & \w{30} &
		\w{21} & \w{19} \\	

		\w{22} & \e{17} & \n{13} & \w{56} & \w{95} & \w{44} & \w{30} &
		\w{21} & \w{19} \\	

		\w{22} & \w{17} & \e{13} & \n{56} & \w{95} & \w{44} & \w{30} &
		\w{21} & \w{19} \\	

		\w{56} & \w{22} & \w{17} & \e{13} & \n{95} & \w{44} & \w{30} &
		\w{21} & \w{19} \\	

		\w{95} & \w{56} & \w{22} & \w{17} & \e{13} & \n{44} & \w{30} &
		\w{21} & \w{19} \\	

		\w{95} & \w{56} & \w{44} & \w{22} & \w{17} & \e{13} & \n{30} &
		\w{21} & \w{19} \\	

		\w{95} & \w{56} & \w{44} & \w{30} & \w{22} & \w{17} & \e{13} & 
		\n{21} & \w{19} \\	

		\w{95} & \w{56} & \w{44} & \w{30} & \w{22} & \w{21} & \w{17} &
		\e{13} & \n{19} \\	

		\w{95} & \w{56} & \w{44} & \w{30} & \w{22} & \w{21} & \w{19} &
		\w{17} & \e{13} \\	
		\hline
	\end{tabular}
	\label{tab:insertionsort}
\end{table}

\subsection*{b)}

\begin{table}[h!]
	\centering
	\begin{tabular}{|c|c|c|c|}
		\hline
		Algorithmus & Iteration & Vertauschungen & Vergleiche \\
		\hline
		\multirow{9}{*}{Selectionsort}
		 & 1 & 1 & 8 \\
		 & 2 & 1 & 7 \\
		 & 3 & 1 & 6 \\
		 & 4 & 1 & 5 \\
		 & 5 & 0 & 4 \\
		 & 6 & 1 & 3 \\
		 & 7 & 1 & 2 \\
		 & 8 & 1 & 1 \\
		 & 9 & 0 & 0 \\
		\hline
		Summe &   & 7 & 36 \\
		\hline
		\hline
		\multirow{8}{*}{Insertionsort} 
		 & 1 & 0 & 1 \\
		 & 2 & 0 & 2 \\
		 & 3 & 3 & 1 \\
		 & 4 & 4 & 1 \\
		 & 5 & 3 & 3 \\
		 & 6 & 3 & 4 \\
		 & 7 & 2 & 6 \\
		 & 8 & 2 & 7 \\
		\hline
		Summe & & 17 & 25 \\
		\hline
	\end{tabular}
	\caption{Anzahl von Elementaroperationen}
	\label{tab:num_of_operations}
\end{table}

\subsection*{Implimentierung Selectionsort:}

\begin{itemize}
	\item Es wird immer die größte Zahl genommen und ans Ende der
		sortierten Liste geschoben.
	\item Zum ermitteln der größten Zahl, muss der unsortierte Teil der
		Liste komplett durchsucht werden.
	\item Pro Iteration ist maximal nur eine Tauschoperation möglich.
\end{itemize}

\subsection*{Implimentierung Insertionsort:}

\begin{itemize}
	\item Es wird immer das erste Element des unsortierten Teil der
		Liste genommen und an die richtige Position der sortierten Liste
		geschoben.
	\item Hierbei werden die Elemente, die kleiner als das einzufügende
		Element, nach hinten geschoben.
\end{itemize}



\clearpage
\section*{H 10.5 Heapsort}

\subsection*{a)}

\fig{heap00} {Ausgangs-Binärbaum, stelle Heapeigenschaften in Knoten 11 her} {heap00}
\fig{heap01} {Stelle Heapeigenschaften in Knoten 3 her}  {heap01}
\fig{heap02} {Stelle Heapeigenschaften in Knoten 15 her} {heap02}
\fig{heap03} {Stelle Heapeigenschaften in Knoten 15 her} {heap03}
\fig{heap04} {Stelle Heapeigenschaften in Knoten 82 her} {heap04}

\clearpage
\subsection*{b)}
\fig{heap04} {82 einsortiern} {heap05}
\fig{heap05} {79 einsortiern} {heap06}
\fig{heap06} {64 einsortiern} {heap07}
\fig{heap07} {39 einsortiern} {heap08}
\fig{heap08} {22 einsortiern} {heap09}
\fig{heap09} {21 einsortiern} {heap10}
\fig{heap10} {15 einsortiern} {heap11}
\fig{heap11} {11 einsortiern} {heap12}
\fig{heap12} {3 einsortiern}  {heap13}


\clearpage
\section*{H 10.6 Stäbe-Teilen}

\subsection*{a)}

\lstinputlisting[language=Java,
	caption={StickDivision.java},
	captionpos=b,
	label=stickdivision]
	{../../../src/main/java/stickDivision/StickDivision.java}

\subsubsection*{Ausgabe:}

\begin{verbatim}
=============================================
0:	q = 0
1:	q = max(0, 1 + 0)
result[1] = 1
0:	q = 0
1:	q = max(0, 1 + 1)
2:	q = max(2, 6 + 0)
result[2] = 6
0:	q = 0
1:	q = max(0, 1 + 6)
2:	q = max(7, 6 + 1)
3:	q = max(7, 8 + 0)
result[3] = 8
0:	q = 0
1:	q = max(0, 1 + 8)
2:	q = max(9, 6 + 6)
3:	q = max(12, 8 + 1)
4:	q = max(12, 11 + 0)
result[4] = 12
0:	q = 0
1:	q = max(0, 1 + 12)
2:	q = max(13, 6 + 8)
3:	q = max(14, 8 + 6)
4:	q = max(14, 11 + 1)
5:	q = max(14, 12 + 0)
result[5] = 14
0:	q = 0
1:	q = max(0, 1 + 14)
2:	q = max(15, 6 + 12)
3:	q = max(18, 8 + 8)
4:	q = max(18, 11 + 6)
5:	q = max(18, 12 + 1)
6:	q = max(18, 19 + 0)
result[6] = 19
0:	q = 0
1:	q = max(0, 1 + 19)
2:	q = max(20, 6 + 14)
3:	q = max(20, 8 + 12)
4:	q = max(20, 11 + 8)
5:	q = max(20, 12 + 6)
6:	q = max(20, 19 + 1)
7:	q = max(20, 20 + 0)
result[7] = 20
0:	q = 0
1:	q = max(0, 1 + 20)
2:	q = max(21, 6 + 19)
3:	q = max(25, 8 + 14)
4:	q = max(25, 11 + 12)
5:	q = max(25, 12 + 8)
6:	q = max(25, 19 + 6)
7:	q = max(25, 20 + 1)
8:	q = max(25, 23 + 0)
result[8] = 25
0:	q = 0
1:	q = max(0, 1 + 25)
2:	q = max(26, 6 + 20)
3:	q = max(26, 8 + 19)
4:	q = max(27, 11 + 14)
5:	q = max(27, 12 + 12)
6:	q = max(27, 19 + 8)
7:	q = max(27, 20 + 6)
8:	q = max(27, 23 + 1)
9:	q = max(27, 26 + 0)
result[9] = 27
0:	q = 0
1:	q = max(0, 1 + 27)
2:	q = max(28, 6 + 25)
3:	q = max(31, 8 + 20)
4:	q = max(31, 11 + 19)
5:	q = max(31, 12 + 14)
6:	q = max(31, 19 + 12)
7:	q = max(31, 20 + 8)
8:	q = max(31, 23 + 6)
9:	q = max(31, 26 + 1)
10:	q = max(31, 30 + 0)
result[10] = 31
=============================================
result = 31
\end{verbatim}

\subsection*{a)}

\lstinputlisting[language=Java,
	caption={StickDivision2.java},
	captionpos=b,
	label=stickdivision2]
	{../../../src/main/java/stickDivision/StickDivision2.java}

\subsubsection*{Ausgabe:}

\begin{verbatim}
Pieces after cutting (length, value):
[2, 6]
[2, 6]
[6, 19]
\end{verbatim}

\subsubsection*{Erläuterung:}

Es wird zusätzlich zu dem bestmöglich Wert für eine Stabteilung der
Länge $n$ die Unterteilung abgespeichert mit der man zuletzt geteilt
hat.
\lstquote{18}{19}
Dann wird dieser zusätliche Wert in einer Map abgespeichert und
zurückgegeben.
\lstquote{26}{30}
Um die Lösung nun zusammenzubauen muss der größte Wert der Map gefunden
werden.
\lstquote{36}{37}
Und dann der von dem Stab Stück für Stück die besten Teile abgebrochen
werden.
\lstquote{39}{46}



\end{document}
