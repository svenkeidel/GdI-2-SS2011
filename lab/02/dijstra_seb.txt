package logic.algorithm;

import java.util.Collections;
import java.util.Comparator;
import java.util.Vector;

import org.apache.log4j.Logger;

import datamodel.Grid;
import datamodel.GridElement;
import static datamodel.GridElementAlgoState.*;

public class Dijkstra implements Algorithm {
	private static final Logger logger = Logger.getLogger(Dijkstra.class);

	public final static int INFINITE = Integer.MAX_VALUE;

	private Grid grid;
	private Vector<GridElement> reachableKnodes;
	private Vector<Integer> wayCosts;
	private Vector<GridElement> possible_reachableKnodes;
	private Vector<Integer> possible_wayCosts;
	private GridElement startKnode, endKnode;
	private Comparator<GridElement> Knodes_comparator;
	private Comparator<Integer> Costs_comparator;

	public void init(Grid grid) {
	logger.info("Initialize Dijkstra");

		this.grid = grid;
		this.startKnode = grid.getStartElement();
		this.endKnode   = grid.getEndElement();
		this.reachableKnodes = new Vector<GridElement>();
		this.Knodes_comparator = getKnodesComparator();
		this.Costs_comparator = getCostsComparator();
		
		if(startKnode == null)
			throw new IllegalStateException(
					"No start knode specified for dijkstra algorithm");

		if(endKnode   == null)
			throw new IllegalStateException(
					"No target knode specified for dijkstra algorithm");

		for(GridElement v : grid.getKnodes()) {
			v.setDistance(INFINITE);
			v.setAlgoState(NONE);
		}

		startKnode.setDistance(0);
		startKnode.setAlgoState(LOOKED_AT);

		
		//Debugging startKnode / endKnode
		logger.debug("S:"+startKnode.getRow()+"|"+startKnode.getColumn()+", E: "+endKnode.getRow()+"|"+endKnode.getColumn()+"");
	
		
		
		// for all neighbors of starKnode: Distance = their Weight
		reachableKnodes = grid.getNeighborsFrom(startKnode, true).getNeighbors();
		wayCosts = grid.getNeighborsFrom(startKnode, true).getWayCosts();
		
		for(int i=0; i < wayCosts.size(); i++){
			reachableKnodes.get(i).setDistance(wayCosts.get(i));
			
		}
	}
	// Svens Code //
	//	for(GridElement neighbor :
	//			grid.getNeighborsFrom(startKnode).getNeighbors() ) {
	//		reachableKnodes.add(neighbor);
	//		neighbor.setDistance(neighbor.getWeight());
			//neighbor.setAlgoState(PATH);
	//	}
	

	//Comparators for GridElement Vector and Integer Vector
	protected Comparator<GridElement> getKnodesComparator() {
		return new Comparator<GridElement>(){
			public int compare(GridElement o1, GridElement o2) {
				return wayCosts.get(reachableKnodes.indexOf(o1)) - wayCosts.get(reachableKnodes.indexOf(o2));
			}
		};
	}

	protected Comparator<Integer> getCostsComparator() {
		return new Comparator<Integer>(){
			public int compare(Integer o1, Integer o2) {
				return o1 - o2;
			}
		};
	}
	
	
	public boolean doNextStep() {

		if(!reachableKnodes.isEmpty() && endKnode.getAlgoState() != LOOKED_AT) {

			//sort reachableKnodes AND wayCosts
			Collections.sort(reachableKnodes, Knodes_comparator);
			Collections.sort(wayCosts, Costs_comparator);
	
			GridElement nearest = reachableKnodes.get(0);
			nearest.setAlgoState(LOOKED_AT);

			reachableKnodes.remove(0);
			wayCosts.remove(0);
			
			//Debugging the deleted nearestKnode
			logger.debug("("+nearest.getRow()+", "+nearest.getColumn()+") "+wayCosts.get(0)+" - "+reachableKnodes.get(0).getDistance()+") D");
			
			//Debugging reachableKnodes, their costs and distance
			for(int i=0; i < reachableKnodes.size(); i++){
				logger.debug("("+reachableKnodes.get(i).getRow()+", "+reachableKnodes.get(i).getColumn()+") "+wayCosts.get(i)+" - "+reachableKnodes.get(i).getDistance()+"");}
				logger.debug("");

				//Vector of possible neighbors and their Costs
				possible_reachableKnodes = grid.getNeighborsFrom(nearest, true).getNeighbors();
				possible_wayCosts = grid.getNeighborsFrom(nearest, true).getWayCosts();
				
				//add just relevant neighbors to reachableKnodes (with extending the wayCosts Vector with their wayCost!!)
				for(int i = 0; i < possible_reachableKnodes.size(); i++) {

				if(possible_reachableKnodes.get(i).getAlgoState() != LOOKED_AT) {
					if(possible_reachableKnodes.get(i).getDistance() == INFINITE)
						reachableKnodes.add(possible_reachableKnodes.get(i));
						wayCosts.add(possible_wayCosts.get(i));
						
				//update Distance of possible Neighbors
					if(nearest.getDistance() + possible_wayCosts.get(i) < possible_reachableKnodes.get(i).getDistance()) {
					possible_reachableKnodes.get(i).setDistance(nearest.getDistance() + possible_wayCosts.get(i));
					//neighbor.setAlgoState(PATH);
				}
				
			}
				}	
				//Svens Code//
				/*for(GridElement neighbor :
						grid.getNeighborsFrom(nearest).getNeighbors() ) {

					if(neighbor.getAlgoState() != LOOKED_AT) {
						if(neighbor.getDistance() == INFINITE)
							reachableKnodes.add(neighbor);

						if(nearest.getDistance() + neighbor.getWeight() < neighbor.getDistance()) {
							neighbor.setDistance(nearest.getDistance() + neighbor.getWeight());
							//neighbor.setAlgoState(PATH);
						}
					}
				}*/
				
			
			return true;
		} else {
			return false;
		}
	}

	public boolean isSolved() {
		return endKnode.getAlgoState() == LOOKED_AT;
	}
}

